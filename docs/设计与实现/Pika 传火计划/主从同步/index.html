<!doctype html>
<html lang="zh-Hans" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-设计与实现/Pika 传火计划/主从同步/index" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.4.0">
<title data-rh="true">Pika 主从同比 | PikiwiDB(Pika)</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://www.pikiwidb.com/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://www.pikiwidb.com/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://www.pikiwidb.com/docs/设计与实现/Pika 传火计划/主从同步/"><meta data-rh="true" property="og:locale" content="zh_Hans"><meta data-rh="true" name="docusaurus_locale" content="zh-Hans"><meta data-rh="true" name="docsearch:language" content="zh-Hans"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="Pika 主从同比 | PikiwiDB(Pika)"><meta data-rh="true" name="description" content="alt text"><meta data-rh="true" property="og:description" content="alt text"><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://www.pikiwidb.com/docs/设计与实现/Pika 传火计划/主从同步/"><link data-rh="true" rel="alternate" href="https://www.pikiwidb.com/docs/设计与实现/Pika 传火计划/主从同步/" hreflang="zh-Hans"><link data-rh="true" rel="alternate" href="https://www.pikiwidb.com/docs/设计与实现/Pika 传火计划/主从同步/" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="PikiwiDB(Pika) RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="PikiwiDB(Pika) Atom Feed">



<link rel="stylesheet" href="/css/katex.min.css"><link rel="stylesheet" href="/assets/css/styles.bf00f426.css">
<script src="/assets/js/runtime~main.ca847e55.js" defer="defer"></script>
<script src="/assets/js/main.a98d41ac.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"light")}(),function(){try{const n=new URLSearchParams(window.location.search).entries();for(var[t,e]of n)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="跳到主要内容"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">跳到主要内容</a></div><nav aria-label="主导航" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="切换导航栏" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/PikiwiDB-Logo.png" alt="Logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/img/PikiwiDB-Logo.png" alt="Logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate"></b></a><a class="navbar__item navbar__link" href="/docs/序言">文档</a><a class="navbar__item navbar__link" href="/blog">博客</a></div><div class="navbar__items navbar__items--right"><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="切换浅色/暗黑模式（当前为浅色模式）" aria-label="切换浅色/暗黑模式（当前为浅色模式）" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="docsWrapper_hBAB"><button aria-label="回到顶部" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docRoot_UBD9"><aside class="theme-doc-sidebar-container docSidebarContainer_YfHR"><div class="sidebarViewport_aRkj"><div class="sidebar_njMd"><nav aria-label="文档侧边栏" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/docs/序言/">序言</a><button aria-label="展开侧边栏分类 &#x27;序言&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/docs/使用与运维/">使用与运维</a><button aria-label="展开侧边栏分类 &#x27;使用与运维&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/docs/性能与优化/">性能与优化</a><button aria-label="展开侧边栏分类 &#x27;性能与优化&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" href="/docs/设计与实现/">设计与实现</a><button aria-label="折叠侧边栏分类 &#x27;设计与实现&#x27;" aria-expanded="true" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/设计与实现/整体技术架构/">整体技术架构</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/设计与实现/线程模型/">线程模型</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/设计与实现/锁的应用/">锁的应用</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/设计与实现/全同步/">全同步</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/设计与实现/增量同步/">增量同步</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/设计与实现/主从同步/">主从同步</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/设计与实现/副本一致性/">副本一致性</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/设计与实现/Pika 与 Codis/">Pika 与 Codis</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/设计与实现/快照式备份/">快照式备份</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/设计与实现/NoSQL 原理概述/">NoSQL 原理概述</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/设计与实现/旧存储结构/">旧存储结构</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/设计与实现/新存储结构/">新存储结构</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/设计与实现/新存储方案：详细解析/">新存储结构：详细解析</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" tabindex="0" href="/docs/设计与实现/Pika 源码学习笔记/">Pika 源码学习笔记</a><button aria-label="展开侧边栏分类 &#x27;Pika 源码学习笔记&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" tabindex="0" href="/docs/设计与实现/Pika 传火计划/">Pika 传火计划</a><button aria-label="折叠侧边栏分类 &#x27;Pika 传火计划&#x27;" aria-expanded="true" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/设计与实现/Pika 传火计划/线程模型/">Pika 线程模型简介</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/设计与实现/Pika 传火计划/读写流程/">Pika 读写流程简介</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/设计与实现/Pika 传火计划/主从同步/">Pika 主从同比</a></li></ul></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/docs/开发文档/">编码规范</a><button aria-label="展开侧边栏分类 &#x27;编码规范&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li></ul></nav></div></div></aside><main class="docMainContainer_TBSr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="页面路径"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="主页面" class="breadcrumbs__link" href="/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><a class="breadcrumbs__link" itemprop="item" href="/docs/设计与实现/"><span itemprop="name">设计与实现</span></a><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><a class="breadcrumbs__link" itemprop="item" href="/docs/设计与实现/Pika 传火计划/"><span itemprop="name">Pika 传火计划</span></a><meta itemprop="position" content="2"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">Pika 主从同比</span><meta itemprop="position" content="3"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">本页总览</button></div><div class="theme-doc-markdown markdown"><header><h1>Pika 主从同比</h1></header><p><img decoding="async" loading="lazy" alt="alt text" src="/assets/images/image-aad65eec86e42083a83018a4357d882b.png" width="572" height="175" class="img_ev3q"></p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="introduction">Introduction<a class="hash-link" aria-label="Introduction的直接链接" title="Introduction的直接链接" href="/docs/设计与实现/Pika 传火计划/主从同步/#introduction">​</a></h2>
<p>Pika的主从同步的概念在经典模式下和集群模式下会有差异，但是其最基本的同步单元都是内部结构Partition的同步。Partition是Pika代码层面的最小同步单元，经典模式下多DB结构，每一个DB对应一个Partition，集群模式下每一个分片对应一个Partition，所以不管是什么模式，只是跳出Pika代码之外的概念有区别，在Pika代码内部统称为Partition的同步。下边主要关注经典模式下多DB的同步流程，集群模式下的同步感兴趣的同学可以自行整理。</p>
<p>Pika 的同步主要分为两个部分，首先是进程级别的同步，确认主从db个数是相同的。这一过程称之为MetaSync。之后每一个Partition单独同步，通过从给主发送的TrySync 信息，查看主从同步点位，从判断需要发起全量同步还是增量同步。全量同步由DbSync 消息来发起，增量同步由BinlogSync 消息来发起。需要注意的是全同步做完，从会再发送一次TrySync消息尝试BinlogSync来同步全同步期间的增量数据。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="同步线程模型">同步线程模型<a class="hash-link" aria-label="同步线程模型的直接链接" title="同步线程模型的直接链接" href="/docs/设计与实现/Pika 传火计划/主从同步/#同步线程模型">​</a></h2>
<p><img decoding="async" loading="lazy" alt="alt text" src="/assets/images/image-1-1ba1cdceb8cda07f155712902543dede.png" width="670" height="415" class="img_ev3q"></p>
<p>Pika的同步模型中，所有同步流程的发起者都是从节点（这一点很重要），MetaSync，TrySync，DbSync，BinlogSync都是从发起到主。在MetaSync，TrySync，DbSync，BinlogSync流程中，主的回复用的连接是从发起请求时建立的连接。即上图中主PikaReplServerThread 到 PikaReplClientThread 的连接。</p>
<div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class PikaAuxiliaryThread : public pink::Thread {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  virtual void* ThreadMain();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  while (!should_stop()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (g_pika_server-&gt;ShouldMetaSync()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      g_pika_rm-&gt;SendMetaSyncRequest();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else if (g_pika_server-&gt;MetaSyncDone()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      g_pika_rm-&gt;RunSyncSlavePartitionStateMachine();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Status s = g_pika_rm-&gt;CheckSyncTimeout(slash::NowMicros());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    s = g_pika_server-&gt;TriggerSendBinlogSync();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int res = g_pika_server-&gt;SendToPeer();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!res) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      // sleep 100 ms</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      mu_.Lock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      cv_.TimedWait(100);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      mu_.Unlock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>辅助线程的工作主要包括1）Pika同步MetaSync消息发送，2）TrySync消息发送，3）驱动BinlogSync流程启动，4）Partition级别的keepalive和超时检测。</p>
<p>其中，SendToPeer函数负责尝试向从发送消息，返回值代表发送了多少条Binlog，如果没有任何可以发送的Binlog，为了让出CPU资源，辅助线程会sleep 100ms。</p>
<div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class PikaReplClient {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  PikaReplClientThread* client_thread_;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  std::vector&lt;PikaReplBgWorker*&gt; bg_workers_;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  Status SendMetaSync();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  Status SendPartitionDBSync(...);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  Status SendPartitionTrySync((...);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  Status SendPartitionBinlogSync(...);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class PikaReplClientThread : public pink::ClientThread {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  class ReplClientConnFactory : public pink::ConnFactory {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    virtual std::shared_ptr&lt;pink::PinkConn&gt; NewPinkConn(...) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      return std::make_shared&lt;PikaReplClientConn&gt;(...);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  class ReplClientHandle : public pink::ClientHandle {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void FdTimeoutHandle(int fd, const std::string&amp; ip_port) const override;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void FdClosedHandle(int fd, const std::string&amp; ip_port) const override;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class PikaReplClientConn: public pink::PbConn {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  int DealMessage() override;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  static void HandleMetaSyncResponse(void* arg);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  static void HandleDBSyncResponse(void* arg);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  static void HandleTrySyncResponse(void* arg);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  void DispatchBinlogRes(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    const std::shared_ptr&lt;InnerMessage::InnerResponse&gt; response);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class PikaReplBgWorker {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  pink::BGThread bg_thread_;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  static void HandleBGWorkerWriteBinlog(void* arg);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  static void HandleBGWorkerWriteDB(void* arg);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>class PikaReplClient 中包含了PikaReplClientThread 异步客户端，和一组PikaReplBgWorker异步处理binlog的读写。并且PikaReplClient中封装了各个协议的Send函数。</p>
<p>1，PikaReplClientThread继承自ClientThread，其本质是一个异步的客户端 ，定义了ReplClientConnFactory和ReplClientHandle。ConnFactory 和ClientHandle 的含义详见Pika传火计划之线程模型。</p>
<p>2，PikaReplClientConn继承自PbConn，其通信协议为Protobuf协议，其中包含了PikaReplClientThread接收到相应协议的处理函数。</p>
<p>3，PikaReplBgWorker是高效处理同步过来Binlog的一组工作线程。PikaReplClientThread接收到相应协议报文后，对于一些阻塞的操作，例如本地Binlog写入和Db的写入等操作会直接安排给PikaReplBgWorker 操作。避免阻塞PikaReplClientThread后续报文的处理。</p>
<div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class PikaReplServer {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // thread pool size PIKA_REPL_SERVER_TP_SIZE 3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  pink::ThreadPool* server_tp_;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  PikaReplServerThread* pika_repl_server_thread_;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  slash::Status SendSlaveBinlogChips(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    const std::string&amp; ip,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int port, const std::vector&lt;WriteTask&gt;&amp; tasks);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  void Schedule(pink::TaskFunc func, void* arg);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class PikaReplServerThread : public pink::HolyThread {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  class ReplServerConnFactory : public pink::ConnFactory {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    virtual std::shared_ptr&lt;pink::PinkConn&gt; NewPinkConn(...) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      return std::make_shared&lt;PikaReplServerConn&gt;(...);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  class ReplServerHandle : public pink::ServerHandle {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    virtual void FdClosedHandle(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int fd, const std::string&amp; ip_port) const override;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class PikaReplServerConn: public pink::PbConn {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  int DealMessage();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  static void HandleMetaSyncRequest(void* arg);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  static void HandleTrySyncRequest(void* arg);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  static void HandleDBSyncRequest(void* arg);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  static void HandleBinlogSyncRequest(void* arg);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>class PikaReplServer 包含了一个小型线程池ThreadPool，和PikaReplServerThread。并且包含了发送Binlog的接口SendSlaveBinlogChips。</p>
<p>1，PikaReplServerThread继承自HolyThread，HolyThread继承自ServerThread，实现了HandleConnEvent和HandleNewConn，是一个单线程的轻量级server。同时也实现了ReplServerConnFactory 和ReplServerHandle。</p>
<p>2，PikaReplServerConn 继承自PbConn，其通信协议也是Protobuf协议。其中还包含了PikaReplServerThread接收到相应协议的处理函数。</p>
<p>3，由于PikaReplServerThread 由于收到Binlog的ack之后会从磁盘中加载下次同步到从的binlog到内存中，所以为了避免阻塞PikaReplServerThread后续报文处理，会阻塞的操作被安排到了ThreadPool 当中。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="主从协商建立同步">主从协商建立同步<a class="hash-link" aria-label="主从协商建立同步的直接链接" title="主从协商建立同步的直接链接" href="/docs/设计与实现/Pika 传火计划/主从同步/#主从协商建立同步">​</a></h2>
<p>主从建立同步的过程分为MetaSync=&gt;TrySync=&gt;BinlogSync，或者MetaSync=&gt;TrySync=&gt;DbSync=&gt;BinlogSync两种模式。MetaSync 是进程之间的主从同步db个数是否一样。TrySync是每一个从Partition主动发起，将自己Binlog的位置发送给主，接收到主的返回TrySyncResp之后，进一步判断是全量同步做DbSync 还是直接可以增量同步做BinlogSync。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="metasync">MetaSync<a class="hash-link" aria-label="MetaSync的直接链接" title="MetaSync的直接链接" href="/docs/设计与实现/Pika 传火计划/主从同步/#metasync">​</a></h3>
<p>在正式建立同步之前需要对于主从进程的的db个数进行确认，这一过程称之为MetaSync。</p>
<p>其交互过程如下。</p>
<p><img decoding="async" loading="lazy" alt="alt text" src="/assets/images/image-2-ee383d7fe734cbee48e267cf23d436ca.png" width="622" height="348" class="img_ev3q"></p>
<div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void PikaReplServerConn::HandleMetaSyncRequest(void* arg) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // build server table meta info</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ...;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // use same conn write back</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  conn-&gt;WriteResp(reply_str);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  conn-&gt;NotifyWrite();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void PikaReplClientConn::HandleMetaSyncResponse(void* arg) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // check if table is the same as master&#x27;s</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  if (!PikaReplClientConn::IsTableStructConsistent(...))) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    g_pika_server-&gt;SyncError();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    conn-&gt;NotifyClose();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  g_pika_server-&gt;FinishMetaSync();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="trysync">TrySync<a class="hash-link" aria-label="TrySync的直接链接" title="TrySync的直接链接" href="/docs/设计与实现/Pika 传火计划/主从同步/#trysync">​</a></h3>
<p>MetaSync之后，每一个Partition单独做TrySync，从的Partition 带着自己当前的同步点位向主做请求。主根据从的TrySync消息，如果本地有从发送过来的点位，则回复建议进行增量同步走BinlogSync流程，如果没有，则回复建议进行全量同步走DbSync流程。</p>
<p><img decoding="async" loading="lazy" alt="alt text" src="/assets/images/image-3-70e011578123f4f449d52b38673d5461.png" width="587" height="306" class="img_ev3q"></p>
<div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void PikaReplServerConn::HandleTrySyncRequest(void* arg) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // master check if slave offset is valid</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ...;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // master check if this slave is already exist</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  if (!partition-&gt;CheckSlaveNodeExist(node.ip(), node.port())) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int32_t session_id = partition-&gt;GenSessionId();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    try_sync_response-&gt;set_session_id(session_id);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Status s = partition-&gt;AddSlaveNode(node.ip(), node.port(), session_id);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Status s = partition-&gt;GetSlaveNodeSession(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        node.ip(), node.port(), &amp;session_id);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    try_sync_response-&gt;set_session_id(session_id);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  onn-&gt;WriteResp(reply_str);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  conn-&gt;NotifyWrite();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void PikaReplClientConn::HandleTrySyncResponse(void* arg) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  if (try_sync_response.reply_code()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      == InnerMessage::InnerResponse::TrySync::kOk) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    slave_partition-&gt;SetMasterSessionId(session_id);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    g_pika_rm-&gt;SendPartitionBinlogSyncAckRequest(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      table_name, partition_id, offset, offset, true);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    slave_partition-&gt;SetReplState(ReplState::kConnected);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  } else if (try_sync_response.reply_code() == kSyncPointBePurged) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // Need To Try DBSync</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    slave_partition-&gt;SetReplState(ReplState::kTryDBSync);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  } else if (try_sync_response.reply_code() == kSyncPointLarger) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // rySync Error, Because the invalid filenum and offset</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    slave_partition-&gt;SetReplState(ReplState::kError);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  } else if (try_sync_response.reply_code() == kError) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    slave_partition-&gt;SetReplState(ReplState::kError);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>从节点接收到TrySyncResponse之后</p>
<p>1，（kOk） 如果从返回没有问题，则进行增量同步，发送BinlogSync消息。</p>
<p>2，（kSyncPointBePurged）如果自己的同步点位，在主节点已经被清除。则进行全量同步，发送DbSync 消息。</p>
<p>3，（kSyncPointLarger）如果从点位比主超前，说明从上的数据有一部分是脏数据，将同步终止（kError），需要管理员介入。</p>
<p>4，（kError）如果主返回的TrySyncResponse 有异常，那么将同步终止（kError），需要管理员介入。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="dbsync">DbSync<a class="hash-link" aria-label="DbSync的直接链接" title="DbSync的直接链接" href="/docs/设计与实现/Pika 传火计划/主从同步/#dbsync">​</a></h3>
<p><img decoding="async" loading="lazy" alt="alt text" src="/assets/images/image-4-b9ef1e863901bfa96ea344faee7feaba.png" width="603" height="359" class="img_ev3q"></p>
<p>Pika全量同步，主要依赖于RSYNC工具，通过system调用起RSYNC进程，将主上数据推到从上。目前从上一直起一个RSYNC常驻进 程，专门负责接收主同步过来的全同步数据。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="master-dbsync-behavior">Master DbSync Behavior<a class="hash-link" aria-label="Master DbSync Behavior的直接链接" title="Master DbSync Behavior的直接链接" href="/docs/设计与实现/Pika 传火计划/主从同步/#master-dbsync-behavior">​</a></h3>
<div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void PikaReplServerConn::HandleDBSyncRequest(void* arg) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // sanity check</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ...;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  g_pika_server-&gt;TryDBSync(node.ip(), node.port() + kPortShiftRSync,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      table_name, partition_id);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  conn-&gt;WriteResp(reply_str);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  conn-&gt;NotifyWrite();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void PikaServer::TryDBSync(const std::string&amp; ip, int port,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                           const std::string&amp; table_name,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                           uint32_t partition_id) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  partition-&gt;BgSavePartition();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  DBSync(ip, port, table_name, partition_id);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>主收到HandleDBSyncRequest</p>
<p>1，调用TryDBSync的BgSavePartition，异步将对应的partition打快照。</p>
<p>2，调用DBSync 异步发送。</p>
<p>为保证打快照和发送的文件的先后循序，这两个任务由同一个线程完成。这个线程会根据放入其消费队列的顺序依次执行任务。这里一定是先执行打快照任务，再执行发送文件任务。</p>
<div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void Partition::BgSavePartition() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  slash::MutexLock l(&amp;bgsave_protector_);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  if (bgsave_info_.bgsaving) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  bgsave_info_.bgsaving = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  BgTaskArg* bg_task_arg = new BgTaskArg();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  bg_task_arg-&gt;partition = shared_from_this();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  g_pika_server-&gt;BGSaveTaskSchedule(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      &amp;DoBgSave, static_cast&lt;void*&gt;(bg_task_arg));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void PikaServer::BGSaveTaskSchedule(pink::TaskFunc func, void* arg) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  bgsave_thread_.StartThread();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  bgsave_thread_.Schedule(func, arg);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void Partition::DoBgSave(void* arg) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // do bgsave https://github.com/Qihoo360/pika/wiki/pika-快照式备份方案</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // generate a info file indicate this snapshot&#x27;s binlog filenum and offset</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>1，调用BGSaveTaskSchedule将打快照任务放入bgsave_thread的消费队列中。</p>
<p>2，bgsave_thread调用DoBgSave 对当前的DB状态打快照并且生成info文件，info文件是代表这个快照对应的binlog filenum和offset 的位置。</p>
<div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void PikaServer::DBSync(const std::string&amp; ip, int port,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        const std::string&amp; table_name,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        uint32_t partition_id) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // check if this partition_is is processing dbsync</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ...;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // Reuse the bgsave_thread_</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // Since we expect BgSave and DBSync execute serially</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  bgsave_thread_.Schedule(&amp;DoDBSync, reinterpret_cast&lt;void*&gt;(arg));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// DoDBSync</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void PikaServer::DbSyncSendFile(const std::string&amp; ip, int port,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                const std::string&amp; table_name,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                uint32_t partition_id) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // sending files</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ...;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // Send info file at last</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ...;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="trysync-1">TrySync<a class="hash-link" aria-label="TrySync的直接链接" title="TrySync的直接链接" href="/docs/设计与实现/Pika 传火计划/主从同步/#trysync-1">​</a></h3>
<p>MetaSync之后，每一个Partition单独做TrySync，从的Partition 带着自己当前的同步点位向主做请求。主根据从的TrySync消息，如果本地有从发送过来的点位，则回复建议进行增量同步走BinlogSync流程，如果没有，则回复建议进行全量同步走DbSync流程。</p>
<p><img decoding="async" loading="lazy" alt="alt text" src="/assets/images/image-5-70e011578123f4f449d52b38673d5461.png" width="587" height="306" class="img_ev3q"></p>
<div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void PikaReplServerConn::HandleTrySyncRequest(void* arg) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // master check if slave offset is valid</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ...;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // master check if this slave is already exist</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  if (!partition-&gt;CheckSlaveNodeExist(node.ip(), node.port())) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int32_t session_id = partition-&gt;GenSessionId();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    try_sync_response-&gt;set_session_id(session_id);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Status s = partition-&gt;AddSlaveNode(node.ip(), node.port(), session_id);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Status s = partition-&gt;GetSlaveNodeSession(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        node.ip(), node.port(), &amp;session_id);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    try_sync_response-&gt;set_session_id(session_id);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  onn-&gt;WriteResp(reply_str);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  conn-&gt;NotifyWrite();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void PikaReplClientConn::HandleTrySyncResponse(void* arg) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  if (try_sync_response.reply_code()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      == InnerMessage::InnerResponse::TrySync::kOk) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    slave_partition-&gt;SetMasterSessionId(session_id);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    g_pika_rm-&gt;SendPartitionBinlogSyncAckRequest(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      table_name, partition_id, offset, offset, true);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    slave_partition-&gt;SetReplState(ReplState::kConnected);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  } else if (try_sync_response.reply_code() == kSyncPointBePurged) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // Need To Try DBSync</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    slave_partition-&gt;SetReplState(ReplState::kTryDBSync);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  } else if (try_sync_response.reply_code() == kSyncPointLarger) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // rySync Error, Because the invalid filenum and offset</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    slave_partition-&gt;SetReplState(ReplState::kError);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  } else if (try_sync_response.reply_code() == kError) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    slave_partition-&gt;SetReplState(ReplState::kError);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>从节点接收到TrySyncResponse之后</p>
<p>1，（kOk） 如果从返回没有问题，则进行增量同步，发送BinlogSync消息。</p>
<p>2，（kSyncPointBePurged）如果自己的同步点位，在主节点已经被清除。则进行全量同步，发送DbSync 消息。</p>
<p>3，（kSyncPointLarger）如果从点位比主超前，说明从上的数据有一部分是脏数据，将同步终止（kError），需要管理员介入。</p>
<p>4，（kError）如果主返回的TrySyncResponse 有异常，那么将同步终止（kError），需要管理员介入。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="dbsync-1">DbSync<a class="hash-link" aria-label="DbSync的直接链接" title="DbSync的直接链接" href="/docs/设计与实现/Pika 传火计划/主从同步/#dbsync-1">​</a></h3>
<p><img decoding="async" loading="lazy" alt="alt text" src="/assets/images/image-6-b9ef1e863901bfa96ea344faee7feaba.png" width="603" height="359" class="img_ev3q"></p>
<p>Pika全量同步，主要依赖于RSYNC工具，通过system调用起RSYNC进程，将主上数据推到从上。目前从上一直起一个RSYNC常驻进程，专门负责接收主同步过来的全同步数据。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="master-dbsync-behavior-1">Master DbSync Behavior<a class="hash-link" aria-label="Master DbSync Behavior的直接链接" title="Master DbSync Behavior的直接链接" href="/docs/设计与实现/Pika 传火计划/主从同步/#master-dbsync-behavior-1">​</a></h3>
<div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void PikaReplServerConn::HandleDBSyncRequest(void* arg) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // sanity check</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // ...;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  g_pika_server-&gt;TryDBSync(node.ip(), node.port() + kPortShiftRSync,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      table_name, partition_id);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  conn-&gt;WriteResp(reply_str);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  conn-&gt;NotifyWrite();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void PikaServer::TryDBSync(const std::string&amp; ip, int port,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                           const std::string&amp; table_name,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                           uint32_t partition_id) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  partition-&gt;BgSavePartition();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  DBSync(ip, port, table_name, partition_id);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>主收到HandleDBSyncRequest</p>
<p>1，调用TryDBSync的BgSavePartition，异步将对应的partition打快照。</p>
<p>2，调用DBSync 异步发送。</p>
<p>为保证打快照和发送的文件的先后循序，这两个任务由同一个线程完成。这个线程会根据放入其消费队列的顺序依次执行任务。这里一定是先执行打快照任务，再执行发送文件任务。</p>
<div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void Partition::BgSavePartition() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  slash::MutexLock l(&amp;bgsave_protector_);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  if (bgsave_info_.bgsaving) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  bgsave_info_.bgsaving = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  BgTaskArg* bg_task_arg = new BgTaskArg();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  bg_task_arg-&gt;partition = shared_from_this();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  g_pika_server-&gt;BGSaveTaskSchedule(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      &amp;DoBgSave, static_cast&lt;void*&gt;(bg_task_arg));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void PikaServer::BGSaveTaskSchedule(pink::TaskFunc func, void* arg) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  bgsave_thread_.StartThread();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  bgsave_thread_.Schedule(func, arg);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void Partition::DoBgSave(void* arg) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // do bgsave https://github.com/Qihoo360/pika/wiki/pika-  快照式备份方案</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // generate a info file indicate this snapshot&#x27;s binlog filenum and offset</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>1，调用BGSaveTaskSchedule将打快照任务放入bgsave_thread的消费队列中。</p>
<p>2，bgsave_thread调用DoBgSave 对当前的DB状态打快照并且生成info文件，info文件是代表这个快照对应的binlog filenum和offset 的位置。</p>
<div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void PikaServer::DBSync(const std::string&amp; ip, int port,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        const std::string&amp; table_name,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        uint32_t partition_id) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // check if this partition_is is processing dbsync</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ...;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // Reuse the bgsave_thread_</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // Since we expect BgSave and DBSync execute serially</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  bgsave_thread_.Schedule(&amp;DoDBSync, reinterpret_cast&lt;void*&gt;(arg));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// DoDBSync</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void PikaServer::DbSyncSendFile(const std::string&amp; ip, int port,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                const std::string&amp; table_name,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                uint32_t partition_id) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // sending files</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ...;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // Send info file at last</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ...;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>1, 调用DBSync 将发送文件的任务放入bgsave_thread的消费队列中。</p>
<p>2，bgsave_thread调用DbSyncSendFile，依次发送快照的文件。最后发送info文件。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="slave-dbsync-behavior">Slave DbSync Behavior<a class="hash-link" aria-label="Slave DbSync Behavior的直接链接" title="Slave DbSync Behavior的直接链接" href="/docs/设计与实现/Pika 传火计划/主从同步/#slave-dbsync-behavior">​</a></h3>
<div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void PikaReplClientConn::HandleDBSyncResponse(void* arg) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  slave_partition-&gt;SetReplState(ReplState::kWaitDBSync);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// PikaAuxiliaryThread invoke this periodically</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Status PikaReplicaManager::RunSyncSlavePartitionStateMachine() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  if (s_partition-&gt;State() == ReplState::kWaitDBSync) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    rtition-&gt;TryUpdateMasterOffset();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">bool Partition::TryUpdateMasterOffset() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 1, Check dbsync finished, got the new binlog offset from info file</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 2, Replace the old db</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 3, Update master offset, and TrySync again</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>1，从收到DBSyncResponse 将partition置为kWaitDBSync。</p>
<p>2，辅助线程PikaAuxiliaryThread 周期性检查DbSync 有没有结束，结束的标志为在本地检测到Info文件的存 在。</p>
<p>3，如果DbSync 检测完，解析info文件的filenum offset，替换本地的Db，本地替换成新的filenum和offset，并且重走TrySync流程，同步DbSync期间产生的增量。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="binlogsync">BinlogSync<a class="hash-link" aria-label="BinlogSync的直接链接" title="BinlogSync的直接链接" href="/docs/设计与实现/Pika 传火计划/主从同步/#binlogsync">​</a></h3>
<p><img decoding="async" loading="lazy" alt="alt text" src="/assets/images/image-7-d3f5bbc5af764f52853c1b30cfbd7f2b.png" width="588" height="486" class="img_ev3q"></p>
<p>BinlogSync的同步逻辑，也是从发起的。</p>
<p>1，从先发送一个BinlogSyncRequest，其中有一个first_send标志，第一次发送设置first_send为True。</p>
<p>2，主上收到BinlogSyncRequest看到first_send为true，则会相应做一些初始化工作，之后将待发送数据写入RM::write_queues中。然后由辅助线程用之前从创建的连接发送write_queues中的Binlog数据。</p>
<p>3，从接到Binlog数据后，返回相应的BinlogSyncAck消息（复用BinlogSyncRequest结构）。</p>
<p>4，主收到BinlogSyncAck会，继续将后续带发送数据再写入write_queues 由辅助线程发送到从。</p>
<p>需要注意的是以下两种场景：</p>
<p>1，当主从数据完全一致，并且过了很久没有同步数据的时候，辅助线程会为了保持连接的keepalive，会每隔kSendKeepAliveTimeout 向这条连接发送keealive消息。并且检查主的last_recv_time，如果超过kRecvKeepAliveTimeout没有收到任何消息，则主动将连接断开。</p>
<p>2，由于从是BinlogSync的发起者，但是一段时间没有数据同步之后，从感知不到主上新的数据写入，从而不能再主动再次发起BinlogSync 流程，这时候需要辅助线程来调用TriggerSendBinlogSync，驱动BinlogSync流程。TriggerSendBinlogSync的主要逻辑就是将新写入的增量放入write_queues，再发送给从。</p>
<div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void PikaReplServerConn::HandleBinlogSyncRequest(void* arg) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  if (is_first_send) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    master_partition-&gt;ActivateSlaveBinlogSync(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        node.ip(), node.port(), range_start);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // read next sync binlog to write_queues</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  s = g_pika_rm-&gt;UpdateSyncBinlogStatus(slave_node, range_start, range_end);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>1，主收到从的BinlogSyncRequest后，如果是第一次发送，则初始化本地的一些参数。</p>
<p>2，主把下一次同步的消息放入write_queues 中。具体主将哪些的Binlog 放入write_queues，参考增量同步滑动窗口设计。</p>
<div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void PikaReplClientConn::DispatchBinlogRes(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    const std::shared_ptr&lt;InnerMessage::InnerResponse&gt; res) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   g_pika_rm-&gt;ScheduleWriteBinlogTask(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        table_name_ + partition_id_, res, PikaReplClientConn)); </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void PikaReplBgWorker::HandleBGWorkerWriteBinlog(void* arg) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  for (InnerResponse binlogs) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    redis_parser_.ProcessInputBuffer(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      redis_parser_start, redis_parser_len, &amp;processed_len);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  g_pika_rm-&gt;SendPartitionBinlogSyncAckRequest(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      table_name, partition_id, ack_start, ack_end);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int PikaReplBgWorker::HandleWriteBinlog(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    pink::RedisParser* parser, const pink::RedisCmdArgsType&amp; argv) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  c_ptr-&gt;Initial(argv, worker-&gt;table_name_);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  partition-&gt;ConsensusProcessLeaderLog(c_ptr, worker-&gt;binlog_item_);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Status ConsensusCoordinator::ProcessLeaderLog(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    std::shared_ptr&lt;Cmd&gt; cmd_ptr, const BinlogItem&amp; attribute) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  Status s = InternalAppendLog(attribute, cmd_ptr, nullptr, nullptr);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // do g_pika_rm-&gt;ScheduleWriteDBTask(); in InternalApplyFollower</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  InternalApplyFollower(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      MemLog::LogItem(LogOffset(), cmd_ptr, nullptr, nullptr));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void PikaReplBgWorker::HandleBGWorkerWriteDB(void* arg) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  c_ptr-&gt;Do(partition);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>从收到主发送的Binlog信息之后</p>
<p>1，调用DispatchBinlogRes，为保证相同partition的binlog 写入顺序，将同talbe_name同partition_id的binlog处理流程安排给同一个线程。</p>
<p>2，PikaReplBgWorker线程调用HandleBGWorkerWriteBinlog，将binlog放入redis_parser中，redis_parser解析出完整的命令后调用HandleWriteBinlog。</p>
<p>3，调用ConsensusProcessLeaderLog=&gt;ProcessLeaderLog，通过InternalAppendLog 写入Binlog，通过InternalApplyFollower调用，ScheduleWriteDBTask。</p>
<p>4，返回步骤2，在写完Binlog之后发送BinlogSyncAckRequest进行下一次BinlogSync。</p>
<p>5，在步骤3中，ScheduleWriteDBTask  之后，PikaReplBgWorker线程调用HandleBGWorkerWriteDB 将数据落盘。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="一致性同步">一致性同步<a class="hash-link" aria-label="一致性同步的直接链接" title="一致性同步的直接链接" href="/docs/设计与实现/Pika 传火计划/主从同步/#一致性同步">​</a></h3>
<p>通过之前的介绍，主从之间的同步使用了Protobuf协议，在使用一致性版本的pika的时候，在Pb协议中添加了ConsensusMeta。通过解析Pb填充的ConsensusMeta的数据，进行一致性下的主从通信。其Pb协议中定义如下。在TrySync和BinlogSync的逻辑中通过判断Pb报文中是否携带ConsensusMeta 来判断对端是否开启一致性功能。</p>
<div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">message ConsensusMeta {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  optional uint32       term        = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // Leader -&gt; Follower prev_log_offset</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // Follower -&gt; Leader last_log_offset</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  optional BinlogOffset log_offset  = 2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  optional BinlogOffset commit      = 3;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  optional bool         reject      = 4;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  repeated BinlogOffset hint        = 5;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>其主要设计见副本一致性设计文档。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="从在一致性场景下的数据写入">从在一致性场景下的数据写入<a class="hash-link" aria-label="从在一致性场景下的数据写入的直接链接" title="从在一致性场景下的数据写入的直接链接" href="/docs/设计与实现/Pika 传火计划/主从同步/#从在一致性场景下的数据写入">​</a></h3>
<div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void PikaReplBgWorker::HandleBGWorkerWriteBinlog(void* arg) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  for (InnerResponse binlogs) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    HandleWriteBinlog();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  if (res-&gt;has_consensus_meta()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    partition-&gt;ConsensusProcessLocalUpdate(leader_commit);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ...;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">PikaReplBgWorker::HandleWriteBinlog(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    pink::RedisParser* parser, const pink::RedisCmdArgsType&amp; argv) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  c_ptr-&gt;Initial(argv, worker-&gt;table_name_);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  partition-&gt;ConsensusProcessLeaderLog(c_ptr, worker-&gt;binlog_item_);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>1, 一致性场景下，在PikaReplBgWorker处理主同步过  来的Binlog 同样调用了ConsensusProcessLeaderLog接口，写入Binlog。</p>
<p>2，在HandleBGWorkerWriteBinlog函数调用的最后，调用ConsensusProcessLocalUpdate 接口，更新从的commit信息，调用ScheduleApplyFollowerLog 将从可以写入DB的请求异步写入DB。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="主在一致性场景下的数据写入">主在一致性场景下的数据写入<a class="hash-link" aria-label="主在一致性场景下的数据写入的直接链接" title="主在一致性场景下的数据写入的直接链接" href="/docs/设计与实现/Pika 传火计划/主从同步/#主在一致性场景下的数据写入">​</a></h3>
<div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void PikaReplServerConn::HandleBinlogSyncRequest(void* arg) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  s = g_pika_rm-&gt;UpdateSyncBinlogStatus(slave_node, range_start, range_end);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Status ConsensusCoordinator::UpdateSlave(const std::string&amp; ip, int port,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      const LogOffset&amp; start, const LogOffset&amp; end) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  LogOffset committed_index;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // invoke InternalCalCommittedIndex to calculate committed_index</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  Status s = sync_pros_.Update(ip, port, start, end, &amp;committed_index);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  if (!s.ok()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return s;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  LogOffset updated_committed_index;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  bool need_update = false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    slash::MutexLock l(&amp;index_mu_);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    need_update = InternalUpdateCommittedIndex(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        committed_index, &amp;updated_committed_index);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  if (need_update) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // sheduel DoExecTask</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    s = ScheduleApplyLog(updated_committed_index);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!s.ok() &amp;&amp; !s.IsNotFound()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      return s;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  return Status::OK();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>1，HandleBinlogSyncRequest =&gt; UpdateSyncBinlogStatus =&gt; ConsensusUpdateSlave =&gt; UpdateSlave</p>
<p>2，UpdateSlave函数中调用sync_pros.Update更新对应的从节点的acked_offset，同时更新这个从的match_index，代表已经同步到该从的最高的LogOffset。然后依据match_index数组计算主上的committed_index。</p>
<p>3，更新主的committed_index。</p>
<p>4，如果成功更新committed_index，进而schedule应用log，每一条可以应用的log调用回调DoExecTask完成对DB的写入。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="reference">Reference<a class="hash-link" aria-label="Reference的直接链接" title="Reference的直接链接" href="/docs/设计与实现/Pika 传火计划/主从同步/#reference">​</a></h2>
<p><a href="https://github.com/Qihoo360/pika/tree/v3.3.4" target="_blank" rel="noopener noreferrer">https://github.com/Qihoo360/pika/tree/v3.3.4</a></p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="row margin-top--sm theme-doc-footer-edit-meta-row"><div class="col"><a href="https://github.com/pikiwidb/website/tree/main/docs/设计与实现/Pika 传火计划/主从同步/index.md" target="_blank" rel="noopener noreferrer" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>编辑此页</a></div><div class="col lastUpdated_JAkA"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="文件选项卡"><a class="pagination-nav__link pagination-nav__link--prev" href="/docs/设计与实现/Pika 传火计划/读写流程/"><div class="pagination-nav__sublabel">上一页</div><div class="pagination-nav__label">Pika 读写流程简介</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/docs/开发文档/"><div class="pagination-nav__sublabel">下一页</div><div class="pagination-nav__label">编码规范</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a class="table-of-contents__link toc-highlight" href="/docs/设计与实现/Pika 传火计划/主从同步/#introduction">Introduction</a></li><li><a class="table-of-contents__link toc-highlight" href="/docs/设计与实现/Pika 传火计划/主从同步/#同步线程模型">同步线程模型</a></li><li><a class="table-of-contents__link toc-highlight" href="/docs/设计与实现/Pika 传火计划/主从同步/#主从协商建立同步">主从协商建立同步</a><ul><li><a class="table-of-contents__link toc-highlight" href="/docs/设计与实现/Pika 传火计划/主从同步/#metasync">MetaSync</a></li><li><a class="table-of-contents__link toc-highlight" href="/docs/设计与实现/Pika 传火计划/主从同步/#trysync">TrySync</a></li><li><a class="table-of-contents__link toc-highlight" href="/docs/设计与实现/Pika 传火计划/主从同步/#dbsync">DbSync</a></li><li><a class="table-of-contents__link toc-highlight" href="/docs/设计与实现/Pika 传火计划/主从同步/#master-dbsync-behavior">Master DbSync Behavior</a></li><li><a class="table-of-contents__link toc-highlight" href="/docs/设计与实现/Pika 传火计划/主从同步/#trysync-1">TrySync</a></li><li><a class="table-of-contents__link toc-highlight" href="/docs/设计与实现/Pika 传火计划/主从同步/#dbsync-1">DbSync</a></li><li><a class="table-of-contents__link toc-highlight" href="/docs/设计与实现/Pika 传火计划/主从同步/#master-dbsync-behavior-1">Master DbSync Behavior</a></li><li><a class="table-of-contents__link toc-highlight" href="/docs/设计与实现/Pika 传火计划/主从同步/#slave-dbsync-behavior">Slave DbSync Behavior</a></li><li><a class="table-of-contents__link toc-highlight" href="/docs/设计与实现/Pika 传火计划/主从同步/#binlogsync">BinlogSync</a></li><li><a class="table-of-contents__link toc-highlight" href="/docs/设计与实现/Pika 传火计划/主从同步/#一致性同步">一致性同步</a></li><li><a class="table-of-contents__link toc-highlight" href="/docs/设计与实现/Pika 传火计划/主从同步/#从在一致性场景下的数据写入">从在一致性场景下的数据写入</a></li><li><a class="table-of-contents__link toc-highlight" href="/docs/设计与实现/Pika 传火计划/主从同步/#主在一致性场景下的数据写入">主在一致性场景下的数据写入</a></li></ul></li><li><a class="table-of-contents__link toc-highlight" href="/docs/设计与实现/Pika 传火计划/主从同步/#reference">Reference</a></li></ul></div></div></div></div></main></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">微信公众号</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://mp.weixin.qq.com/s/CvIdQs3g31DC8JztyymuqQ" target="_blank" rel="noopener noreferrer" class="footer__link-item">PikiwiDB(Pika) 公众号<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">Github 仓库</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://github.com/OpenAtomFoundation/pika" target="_blank" rel="noopener noreferrer" class="footer__link-item">PikiwiDB(Pika) 仓库<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">文档仓库</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://github.com/pikiwidb/website" target="_blank" rel="noopener noreferrer" class="footer__link-item">PikiwiDB(Pika) 文档仓库<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2024 PikiwiDB 开源数据库社区</div></div></div></footer></div>
</body>
</html>