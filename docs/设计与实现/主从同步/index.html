<!doctype html>
<html lang="zh-Hans" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-设计与实现/主从同步/index" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.4.0">
<title data-rh="true">主从同步 | PikiwiDB(Pika)</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://www.pikiwidb.com/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://www.pikiwidb.com/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://www.pikiwidb.com/docs/设计与实现/主从同步/"><meta data-rh="true" property="og:locale" content="zh_Hans"><meta data-rh="true" name="docusaurus_locale" content="zh-Hans"><meta data-rh="true" name="docsearch:language" content="zh-Hans"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="主从同步 | PikiwiDB(Pika)"><meta data-rh="true" name="description" content="pika主从同步"><meta data-rh="true" property="og:description" content="pika主从同步"><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://www.pikiwidb.com/docs/设计与实现/主从同步/"><link data-rh="true" rel="alternate" href="https://www.pikiwidb.com/docs/设计与实现/主从同步/" hreflang="zh-Hans"><link data-rh="true" rel="alternate" href="https://www.pikiwidb.com/docs/设计与实现/主从同步/" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="PikiwiDB(Pika) RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="PikiwiDB(Pika) Atom Feed">



<link rel="stylesheet" href="/css/katex.min.css"><link rel="stylesheet" href="/assets/css/styles.bf00f426.css">
<script src="/assets/js/runtime~main.c2e559e3.js" defer="defer"></script>
<script src="/assets/js/main.0503a5be.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"light")}(),function(){try{const n=new URLSearchParams(window.location.search).entries();for(var[t,e]of n)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="跳到主要内容"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">跳到主要内容</a></div><nav aria-label="主导航" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="切换导航栏" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/PikiwiDB-Logo.png" alt="Logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/img/PikiwiDB-Logo.png" alt="Logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate"></b></a><a class="navbar__item navbar__link" href="/docs/序言">文档</a><a class="navbar__item navbar__link" href="/blog">博客</a></div><div class="navbar__items navbar__items--right"><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="切换浅色/暗黑模式（当前为浅色模式）" aria-label="切换浅色/暗黑模式（当前为浅色模式）" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="docsWrapper_hBAB"><button aria-label="回到顶部" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docRoot_UBD9"><aside class="theme-doc-sidebar-container docSidebarContainer_YfHR"><div class="sidebarViewport_aRkj"><div class="sidebar_njMd"><nav aria-label="文档侧边栏" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/docs/序言/">序言</a><button aria-label="展开侧边栏分类 &#x27;序言&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/docs/使用与运维/">使用与运维</a><button aria-label="展开侧边栏分类 &#x27;使用与运维&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/docs/性能与优化/">性能与优化</a><button aria-label="展开侧边栏分类 &#x27;性能与优化&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" href="/docs/设计与实现/">设计与实现</a><button aria-label="折叠侧边栏分类 &#x27;设计与实现&#x27;" aria-expanded="true" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/设计与实现/整体技术架构/">整体技术架构</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/设计与实现/线程模型/">线程模型</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/设计与实现/锁的应用/">锁的应用</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/设计与实现/全同步/">全同步</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/设计与实现/增量同步/">增量同步</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/设计与实现/主从同步/">主从同步</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/设计与实现/副本一致性/">副本一致性</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/设计与实现/Pika 与 Codis/">Pika 与 Codis</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/设计与实现/快照式备份/">快照式备份</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/设计与实现/NoSQL 原理概述/">NoSQL 原理概述</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/设计与实现/旧存储结构/">旧存储结构</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/设计与实现/新存储结构/">新存储结构</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/设计与实现/新存储方案：详细解析/">新存储结构：详细解析</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" tabindex="0" href="/docs/设计与实现/Pika 源码学习笔记/">Pika 源码学习笔记</a><button aria-label="展开侧边栏分类 &#x27;Pika 源码学习笔记&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" tabindex="0" href="/docs/设计与实现/Pika 传火计划/">Pika 传火计划</a><button aria-label="展开侧边栏分类 &#x27;Pika 传火计划&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/docs/开发文档/">编码规范</a><button aria-label="展开侧边栏分类 &#x27;编码规范&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li></ul></nav></div></div></aside><main class="docMainContainer_TBSr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="页面路径"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="主页面" class="breadcrumbs__link" href="/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><a class="breadcrumbs__link" itemprop="item" href="/docs/设计与实现/"><span itemprop="name">设计与实现</span></a><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">主从同步</span><meta itemprop="position" content="2"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">本页总览</button></div><div class="theme-doc-markdown markdown"><header><h1>主从同步</h1></header><h2 class="anchor anchorWithStickyNavbar_LWe7" id="pika主从同步">pika主从同步<a class="hash-link" aria-label="pika主从同步的直接链接" title="pika主从同步的直接链接" href="/docs/设计与实现/主从同步/#pika主从同步">​</a></h2>
<p>主要为了分析探索一下pika是如何实现主从同步的，pika的主从同步的原理与redis的同步方案还不相同，本文主要是为了分析其主从同步的相关流程（pika基于3.4版本）。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="pika主从同步原理">pika主从同步原理<a class="hash-link" aria-label="pika主从同步原理的直接链接" title="pika主从同步原理的直接链接" href="/docs/设计与实现/主从同步/#pika主从同步原理">​</a></h2>
<p>主从同步的原理，主要是通过在启动的时候启动了两部分的线程来进行的。</p>
<ul>
<li>auxiliary_thread线程</li>
<li>pika_rm中的pika_repl_client线程池和pika_repl_server线程池</li>
</ul>
<p>先逐个分析一下两个部分线程的工作的流程。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="auxiliary_thread线程">auxiliary_thread线程<a class="hash-link" aria-label="auxiliary_thread线程的直接链接" title="auxiliary_thread线程的直接链接" href="/docs/设计与实现/主从同步/#auxiliary_thread线程">​</a></h3>
<p>在pika的pika_server的Start函数中启动了auxiliary_thread线程。</p>
<div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">  ret = pika_auxiliary_thread_-&gt;StartThread();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  if (ret != pink::kSuccess) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    tables_.clear();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    LOG(FATAL) &lt;&lt; &quot;Start Auxiliary Thread Error: &quot; &lt;&lt; ret &lt;&lt; (ret == pink::kCreateThreadError ? &quot;: create thread error &quot; : &quot;: other error&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>此时启动的线程就是位于pika_auxiliary_thread.cc中的线程函数。</p>
<div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void* PikaAuxiliaryThread::ThreadMain() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  while (!should_stop()) {            //  是否停止线程</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (g_pika_conf-&gt;classic_mode()) {    // 判断当前运行的模式 是分布式模式还是经典模式</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      if (g_pika_server-&gt;ShouldMetaSync()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        g_pika_rm-&gt;SendMetaSyncRequest();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      } else if (g_pika_server-&gt;MetaSyncDone()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        g_pika_rm-&gt;RunSyncSlavePartitionStateMachine();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      g_pika_rm-&gt;RunSyncSlavePartitionStateMachine();  // 分布式模式则直接启动状态机的同步</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Status s = g_pika_rm-&gt;CheckSyncTimeout(slash::NowMicros());  // 检查超时的节点</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!s.ok()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      LOG(WARNING) &lt;&lt; s.ToString();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // TODO(whoiami) timeout</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    s = g_pika_server-&gt;TriggerSendBinlogSync();     // 触发binlog的主从同步</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!s.ok()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      LOG(WARNING) &lt;&lt; s.ToString();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // send to peer</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int res = g_pika_server-&gt;SendToPeer();   // 将待发送的任务加入到工作线程队列中</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!res) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      // sleep 100 ms</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      mu_.Lock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      cv_.TimedWait(100);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      mu_.Unlock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      //LOG_EVERY_N(INFO, 1000) &lt;&lt; &quot;Consume binlog number &quot; &lt;&lt; res;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  return NULL;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="runsyncslavepartitionstatemachine-">RunSyncSlavePartitionStateMachine-<a class="hash-link" aria-label="RunSyncSlavePartitionStateMachine-的直接链接" title="RunSyncSlavePartitionStateMachine-的直接链接" href="/docs/设计与实现/主从同步/#runsyncslavepartitionstatemachine-">​</a></h4>
<p>该函数就是处理主从同步过程中的状态机，根据不同的状态去进行不同的操作。</p>
<div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Status PikaReplicaManager::RunSyncSlavePartitionStateMachine() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  slash::RWLock l(&amp;partitions_rw_, false);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  for (const auto&amp; item : sync_slave_partitions_) {   // 获取所有的从节点同步信息</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    PartitionInfo p_info = item.first;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    std::shared_ptr&lt;SyncSlavePartition&gt; s_partition = item.second;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (s_partition-&gt;State() == ReplState::kTryConnect) {   // 如果同步的信息是kTryConnect则发送TrySync的同步请求</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      LOG(WARNING) &lt;&lt; &quot;Partition start, Table Name: &quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          &lt;&lt; p_info.table_name_ &lt;&lt; &quot; Partition Id: &quot; &lt;&lt; p_info.partition_id_;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      SendPartitionTrySyncRequest(p_info.table_name_, p_info.partition_id_);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else if (s_partition-&gt;State() == ReplState::kTryDBSync) {  // 如果是kTryDB的状态则发送DB同步的请求</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      SendPartitionDBSyncRequest(p_info.table_name_, p_info.partition_id_);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else if (s_partition-&gt;State() == ReplState::kWaitReply) {  // 如果是wait状态则什么都不做</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      continue;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else if (s_partition-&gt;State() == ReplState::kWaitDBSync) {  // 如果是waitdb状态则等待</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      std::shared_ptr&lt;Partition&gt; partition =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          g_pika_server-&gt;GetTablePartitionById(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  p_info.table_name_, p_info.partition_id_);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      if (partition) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        partition-&gt;TryUpdateMasterOffset();   // 更新和主之间的offset</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        LOG(WARNING) &lt;&lt; &quot;Partition not found, Table Name: &quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          &lt;&lt; p_info.table_name_ &lt;&lt; &quot; Partition Id: &quot; &lt;&lt; p_info.partition_id_;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else if (s_partition-&gt;State() == ReplState::kConnected</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      || s_partition-&gt;State() == ReplState::kNoConnect</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      || s_partition-&gt;State() == ReplState::kDBNoConnect) {  // 如果是已连接或者失联则什么都不处理</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      continue;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  return Status::OK();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>从状态机的运行来看，所有的步骤都是依赖于该函数通过状态来驱动进行不同的操作。</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="checksynctimeout-检查连接的超时时间">CheckSyncTimeout-检查连接的超时时间<a class="hash-link" aria-label="CheckSyncTimeout-检查连接的超时时间的直接链接" title="CheckSyncTimeout-检查连接的超时时间的直接链接" href="/docs/设计与实现/主从同步/#checksynctimeout-检查连接的超时时间">​</a></h4>
<div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Status PikaReplicaManager::CheckSyncTimeout(uint64_t now) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  slash::RWLock l(&amp;partitions_rw_, false);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  for (auto&amp; iter : sync_master_partitions_) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    std::shared_ptr&lt;SyncMasterPartition&gt; partition = iter.second;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Status s = partition-&gt;CheckSyncTimeout(now);  // 获取所有的master的同步节点检查是否超时</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!s.ok()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      LOG(WARNING) &lt;&lt; &quot;CheckSyncTimeout Failed &quot; &lt;&lt; s.ToString();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  for (auto&amp; iter : sync_slave_partitions_) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    std::shared_ptr&lt;SyncSlavePartition&gt; partition = iter.second;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Status s = partition-&gt;CheckSyncTimeout(now);  // 获取所有slave的同步节点信息检查是否超时</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!s.ok()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      LOG(WARNING) &lt;&lt; &quot;CheckSyncTimeout Failed &quot; &lt;&lt; s.ToString();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  return Status::OK();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>主要是检查master和slave的同步连接信息是否超时。</p>
<div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Status SyncMasterPartition::CheckSyncTimeout(uint64_t now) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  std::unordered_map&lt;std::string, std::shared_ptr&lt;SlaveNode&gt;&gt; slaves = GetAllSlaveNodes();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  std::vector&lt;Node&gt; to_del;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  for (auto&amp; slave_iter : slaves) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    std::shared_ptr&lt;SlaveNode&gt; slave_ptr = slave_iter.second;   // 获取所有slave的连接信息</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    slash::MutexLock l(&amp;slave_ptr-&gt;slave_mu);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (slave_ptr-&gt;LastRecvTime() + kRecvKeepAliveTimeout &lt; now) {  // 如果最后的时间超时则删除该连接</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      to_del.push_back(Node(slave_ptr-&gt;Ip(), slave_ptr-&gt;Port()));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else if (slave_ptr-&gt;LastSendTime() + kSendKeepAliveTimeout &lt; now &amp;&amp; slave_ptr-&gt;sent_offset == slave_ptr-&gt;acked_offset) {  // 如果最后的发送时间未超时 并且主从同步的偏移量发送的与回复的相同则发送binlogchips请求并且更新当前的最后发送时间</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      std::vector&lt;WriteTask&gt; task;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      RmNode rm_node(slave_ptr-&gt;Ip(), slave_ptr-&gt;Port(), slave_ptr-&gt;TableName(), slave_ptr-&gt;PartitionId(), slave_ptr-&gt;SessionId());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      WriteTask empty_task(rm_node, BinlogChip(LogOffset(), &quot;&quot;), LogOffset());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      task.push_back(empty_task);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      Status s = g_pika_rm-&gt;SendSlaveBinlogChipsRequest(slave_ptr-&gt;Ip(), slave_ptr-&gt;Port(), task);    // 同步当前的主从同步的信息</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      slave_ptr-&gt;SetLastSendTime(now);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      if (!s.ok()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        LOG(INFO)&lt;&lt; &quot;Send ping failed: &quot; &lt;&lt; s.ToString();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return Status::Corruption(&quot;Send ping failed: &quot; + slave_ptr-&gt;Ip() + &quot;:&quot; + std::to_string(slave_ptr-&gt;Port()));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  for (auto&amp; node : to_del) {  // 将超时的连接信息都删除掉</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    coordinator_.SyncPros().RemoveSlaveNode(node.Ip(), node.Port());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    g_pika_rm-&gt;DropItemInWriteQueue(node.Ip(), node.Port());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    LOG(WARNING) &lt;&lt; SyncPartitionInfo().ToString() &lt;&lt; &quot; Master del Recv Timeout slave success &quot; &lt;&lt; node.ToString();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  return Status::OK();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>主节点主要维护了当前的一些主从连接的信息维护。</p>
<div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Status SyncSlavePartition::CheckSyncTimeout(uint64_t now) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  slash::MutexLock l(&amp;partition_mu_);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // no need to do session keepalive return ok</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  if (repl_state_ != ReplState::kWaitDBSync &amp;&amp; repl_state_ != ReplState::kConnected) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return Status::OK();  // 如果从节点的信息不是waitdb或者连接状态则返回ok</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  if (m_info_.LastRecvTime() + kRecvKeepAliveTimeout &lt; now) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // update slave state to kTryConnect, and try reconnect to master node</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    repl_state_ = ReplState::kTryConnect;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    g_pika_server-&gt;SetLoopPartitionStateMachine(true);  // 否则就设置成tryconnect状态去尝试连接主节点</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  return Status::OK();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="triggersendbinlogsync-生成每个节点待发送的数据任务">TriggerSendBinlogSync-生成每个节点待发送的数据任务<a class="hash-link" aria-label="TriggerSendBinlogSync-生成每个节点待发送的数据任务的直接链接" title="TriggerSendBinlogSync-生成每个节点待发送的数据任务的直接链接" href="/docs/设计与实现/主从同步/#triggersendbinlogsync-生成每个节点待发送的数据任务">​</a></h4>
<div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Status PikaServer::TriggerSendBinlogSync() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  return g_pika_rm-&gt;WakeUpBinlogSync();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Status PikaReplicaManager::WakeUpBinlogSync() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  slash::RWLock l(&amp;partitions_rw_, false);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  for (auto&amp; iter : sync_master_partitions_) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    std::shared_ptr&lt;SyncMasterPartition&gt; partition = iter.second;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Status s = partition-&gt;WakeUpSlaveBinlogSync(); // 检查每个节点是否需要生成binlog同步任务</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!s.ok()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      return s;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  return Status::OK();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>主要是检查每个连接的从节点信息是否需要生成同步binlog任务。</p>
<div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Status SyncMasterPartition::WakeUpSlaveBinlogSync() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  std::unordered_map&lt;std::string, std::shared_ptr&lt;SlaveNode&gt;&gt; slaves = GetAllSlaveNodes();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  std::vector&lt;std::shared_ptr&lt;SlaveNode&gt;&gt; to_del;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  for (auto&amp; slave_iter : slaves) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    std::shared_ptr&lt;SlaveNode&gt; slave_ptr = slave_iter.second;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    slash::MutexLock l(&amp;slave_ptr-&gt;slave_mu);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (slave_ptr-&gt;sent_offset == slave_ptr-&gt;acked_offset) {  // 检查当前同步的数据信息是否跟回复的数据偏移相同</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      Status s = ReadBinlogFileToWq(slave_ptr);  // 写binlog任务到该从节点连接上面</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      if (!s.ok()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        to_del.push_back(slave_ptr);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        LOG(WARNING) &lt;&lt; &quot;WakeUpSlaveBinlogSync falied, Delete from RM, slave: &quot; &lt;&lt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          slave_ptr-&gt;ToStringStatus() &lt;&lt; &quot; &quot; &lt;&lt; s.ToString();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  for (auto&amp; to_del_slave : to_del) {  // 如果同步失败则删除该node</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    RemoveSlaveNode(to_del_slave-&gt;Ip(), to_del_slave-&gt;Port());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  return Status::OK();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>其中ReadBinlogFileToWq就是根据当前的连接来生成binlog同步任务。</p>
<div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Status SyncMasterPartition::ReadBinlogFileToWq(const std::shared_ptr&lt;SlaveNode&gt;&amp; slave_ptr) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  int cnt = slave_ptr-&gt;sync_win.Remaining();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  std::shared_ptr&lt;PikaBinlogReader&gt; reader = slave_ptr-&gt;binlog_reader;  //获取当前binlogreader</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  if (reader == nullptr) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return Status::OK();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  std::vector&lt;WriteTask&gt; tasks;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  for (int i = 0; i &lt; cnt; ++i) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    std::string msg;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    uint32_t filenum;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    uint64_t offset;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (slave_ptr-&gt;sync_win.GetTotalBinlogSize() &gt; PIKA_MAX_CONN_RBUF_HB * 2) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      LOG(INFO) &lt;&lt; slave_ptr-&gt;ToString() &lt;&lt; &quot; total binlog size in sync window is :&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                &lt;&lt; slave_ptr-&gt;sync_win.GetTotalBinlogSize();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      break;  //检查当前同步窗口的大小</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Status s = reader-&gt;Get(&amp;msg, &amp;filenum, &amp;offset);  //获取对应的偏移数据</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (s.IsEndFile()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else if (s.IsCorruption() || s.IsIOError()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      LOG(WARNING) &lt;&lt; SyncPartitionInfo().ToString()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        &lt;&lt; &quot; Read Binlog error : &quot; &lt;&lt; s.ToString();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      return s;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    BinlogItem item;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!PikaBinlogTransverter::BinlogItemWithoutContentDecode(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          TypeFirst, msg, &amp;item)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      LOG(WARNING) &lt;&lt; &quot;Binlog item decode failed&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      return Status::Corruption(&quot;Binlog item decode failed&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    BinlogOffset sent_b_offset = BinlogOffset(filenum, offset);   // 生成发送的偏移量</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    LogicOffset sent_l_offset = LogicOffset(item.term_id(), item.logic_id());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    LogOffset sent_offset(sent_b_offset, sent_l_offset);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    slave_ptr-&gt;sync_win.Push(SyncWinItem(sent_offset, msg.size()));  //设置同步窗口的大小</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    slave_ptr-&gt;SetLastSendTime(slash::NowMicros());   //设置最后的发送时间</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    RmNode rm_node(slave_ptr-&gt;Ip(), slave_ptr-&gt;Port(), slave_ptr-&gt;TableName(), slave_ptr-&gt;PartitionId(), slave_ptr-&gt;SessionId());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    WriteTask task(rm_node, BinlogChip(sent_offset, msg), slave_ptr-&gt;sent_offset);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    tasks.push_back(task);  // 包装成任务</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    slave_ptr-&gt;sent_offset = sent_offset;  // 设置当前的发送偏移量</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  if (!tasks.empty()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    g_pika_rm-&gt;ProduceWriteQueue(slave_ptr-&gt;Ip(), slave_ptr-&gt;Port(), partition_info_.partition_id_, tasks);  // 将任务放入队列中等待处理</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  return Status::OK();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>主要就是通过获取偏移量，然后生成任务并放入发送队列中等待处理。</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="sendtopeer-将待发送的binlog同步任务发 送给从节点">SendToPeer-将待发送的binlog同步任务发送给从节点<a class="hash-link" aria-label="SendToPeer-将待发送的binlog同步任务发送给从节点的直接链接" title="SendToPeer-将待发送的binlog同步任务发送给从节点的直接链接" href="/docs/设计与实现/主从同步/#sendtopeer-将待发送的binlog同步任务发送给从节点">​</a></h4>
<div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int PikaServer::SendToPeer() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  return g_pika_rm-&gt;ConsumeWriteQueue();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int PikaReplicaManager::ConsumeWriteQueue() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  std::unordered_map&lt;std::string, std::vector&lt;std::vector&lt;WriteTask&gt;&gt;&gt; to_send_map;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  int counter = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    slash::MutexLock l(&amp;write_queue_mu_);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (auto&amp; iter : write_queues_) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      const std::string&amp; ip_port = iter.first;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      std::unordered_map&lt;uint32_t, std::queue&lt;WriteTask&gt;&gt;&amp; p_map = iter.second; //获取队列</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      for (auto&amp; partition_queue : p_map) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        std::queue&lt;WriteTask&gt;&amp; queue = partition_queue.second;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 0; i &lt; kBinlogSendPacketNum; ++i) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          if (queue.empty()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          size_t batch_index = queue.size() &gt; kBinlogSendBatchNum ? kBinlogSendBatchNum : queue.size();   // 检查当前可发送的大小</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          std::vector&lt;WriteTask&gt; to_send;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          int batch_size = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          for (size_t i = 0; i &lt; batch_index; ++i) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            WriteTask&amp; task = queue.front();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            batch_size +=  task.binlog_chip_.binlog_.size();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // make sure SerializeToString will not over 2G</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (batch_size &gt; PIKA_MAX_CONN_RBUF_HB) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">              break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            to_send.push_back(task);  // 放入可发送的队列中</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            queue.pop();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            counter++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          if (!to_send.empty()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            to_send_map[ip_port].push_back(std::move(to_send));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  std::vector&lt;std::string&gt; to_delete;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  for (auto&amp; iter : to_send_map) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    std::string ip;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int port = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!slash::ParseIpPortString(iter.first, ip, port)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      LOG(WARNING) &lt;&lt; &quot;Parse ip_port error &quot; &lt;&lt; iter.first;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      continue;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (auto&amp; to_send : iter.second) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      Status s = pika_repl_server_-&gt;SendSlaveBinlogChips(ip, port, to_send); // 发送Binglog任务</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      if (!s.ok()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        LOG(WARNING) &lt;&lt; &quot;send binlog to &quot; &lt;&lt; ip &lt;&lt; &quot;:&quot; &lt;&lt; port &lt;&lt; &quot; failed, &quot; &lt;&lt; s.ToString();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        to_delete.push_back(iter.first);  // 如果发送失败则放入失败队列中</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        continue;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  if (!to_delete.empty()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      slash::MutexLock l(&amp;write_queue_mu_);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      for (auto&amp; del_queue : to_delete) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        write_queues_.erase(del_queue);  //删除发送失败的任务</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  return counter;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>最终通过pika_repl_server_的SendSlaveBinlogChip<a href="https://so.csdn.net/so/search?q=s%E5%87%BD%E6%95%B0&amp;spm=1001.2101.3001.7020" target="_blank" rel="noopener noreferrer">s函数</a>将当前待发送的任务发送出去。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="pika_repl_client和pika_repl_server_线程">pika_repl_client和pika_repl_server_线程<a class="hash-link" aria-label="pika_repl_client和pika_repl_server_线程的直接链接" title="pika_repl_client和pika_repl_server_线程的直接链接" href="/docs/设计与实现/主从同步/#pika_repl_client和pika_repl_server_线程">​</a></h3>
<p>这两个线程就是维护了主从连接的client和server端的交互功能，auxiliary_thread中状态机触发的连接状态就是依赖于这两个线程来完成交互。</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="pika_repl_client客户端连接管理线程">pika_repl_client客户端连接管理线程<a class="hash-link" aria-label="pika_repl_client客户端连接管理线程的直接链接" title="pika_repl_client客户端连接管理线程的直接链接" href="/docs/设计与实现/主从同步/#pika_repl_client客户端连接管理线程">​</a></h4>
<p>pika_reple_client的最核心的原理就是通过一个基于epoll（linux平台）的事件驱动，去完成多个连接的事件驱动，并通过加入线程池来提供epoll的处理性能。接下来就大致了解一下pika_repl_client完成的交互的相关功能。</p>
<p>在主从同步过程中，无论是pika_repl_client还是pika_repl_server_底层都利用了pink库的PbConn模式来进行的数据交互。</p>
<p>通过client_thread的逻辑流程来简单分析一下PbConn的执行流程。</p>
<p>在PikaReplClient的Start流程中，启动了如下线程。</p>
<div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int PikaReplClient::Start() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  int res = client_thread_-&gt;StartThread();   // 启动一个epoll的事件驱动</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  if (res != pink::kSuccess) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    LOG(FATAL) &lt;&lt; &quot;Start ReplClient ClientThread Error: &quot; &lt;&lt; res &lt;&lt; (res == pink::kCreateThreadError ? &quot;: create thread error &quot; : &quot;: other error&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  for (size_t i = 0; i &lt; bg_workers_.size(); ++i) {  // 通过将epoll事件驱动的执行分发到线程池中执行</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    res = bg_workers_[i]-&gt;StartThread();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (res != pink::kSuccess) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      LOG(FATAL) &lt;&lt; &quot;Start Pika Repl Worker Thread Error: &quot; &lt;&lt; res</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        &lt;&lt; (res == pink::kCreateThreadError ? &quot;: create thread error &quot; : &quot;: other error&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  return res;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>此时client_thread启动的就是位于pink的client_thread.c中的ClientThread线程。</p>
<div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void *ClientThread::ThreadMain() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  int nfds = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  PinkFiredEvent *pfe = NULL;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  struct timeval when;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  gettimeofday(&amp;when, NULL);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  struct timeval now = when;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  when.tv_sec += (cron_interval_ / 1000);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  when.tv_usec += ((cron_interval_ % 1000) * 1000);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  int timeout = cron_interval_;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  if (timeout &lt;= 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    timeout = PINK_CRON_INTERVAL;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  std::string ip_port;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  while (!should_stop()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (cron_interval_ &gt; 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      gettimeofday(&amp;now, nullptr);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      if (when.tv_sec &gt; now.tv_sec ||</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          (when.tv_sec == now.tv_sec &amp;&amp; when.tv_usec &gt; now.tv_usec)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        timeout = (when.tv_sec - now.tv_sec) * 1000 +</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          (when.tv_usec - now.tv_usec) / 1000;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // do user defined cron</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        handle_-&gt;CronHandle();   // 执行定时任务</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        DoCronTask();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        when.tv_sec = now.tv_sec + (cron_interval_ / 1000);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        when.tv_usec = now.tv_usec + ((cron_interval_ % 1000) * 1000);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        timeout = cron_interval_;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //InternalDebugPrint();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    nfds = pink_epoll_-&gt;PinkPoll(timeout);  //事件驱动</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int i = 0; i &lt; nfds; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      pfe = (pink_epoll_-&gt;firedevent()) + i;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      if (pfe == NULL) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        continue;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      if (pfe-&gt;fd == pink_epoll_-&gt;notify_receive_fd()) {  // 处理驱动</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ProcessNotifyEvents(pfe);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        continue;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      int should_close = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      std::map&lt;int, std::shared_ptr&lt;PinkConn&gt;&gt;::iterator iter = fd_conns_.find(pfe-&gt;fd);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      if (iter == fd_conns_.end()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        log_info(&quot;fd %d not found in fd_conns\n&quot;, pfe-&gt;fd);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        pink_epoll_-&gt;PinkDelEvent(pfe-&gt;fd);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        continue;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      std::shared_ptr&lt;PinkConn&gt; conn = iter-&gt;second;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      if (connecting_fds_.count(pfe-&gt;fd)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Status s = ProcessConnectStatus(pfe, &amp;should_close);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (!s.ok()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          handle_-&gt;DestConnectFailedHandle(conn-&gt;ip_port(), s.ToString());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        connecting_fds_.erase(pfe-&gt;fd);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      if (!should_close &amp;&amp; (pfe-&gt;mask &amp; EPOLLOUT) &amp;&amp; conn-&gt;is_reply()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        WriteStatus write_status = conn-&gt;SendReply();   // 如果当前是可以写数据则调用SendReply</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        conn-&gt;set_last_interaction(now);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (write_status == kWriteAll) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          pink_epoll_-&gt;PinkModEvent(pfe-&gt;fd, 0, EPOLLIN);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          conn-&gt;set_is_reply(false);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else if (write_status == kWriteHalf) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          continue;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          log_info(&quot;send reply error %d\n&quot;, write_status);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          should_close = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      if (!should_close &amp;&amp; (pfe-&gt;mask &amp; EPOLLIN)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ReadStatus read_status = conn-&gt;GetRequest();  // 如果是接受数据则调用GetRequest来解析</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        conn-&gt;set_last_interaction(now);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (read_status == kReadAll) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          // pink_epoll_-&gt;PinkModEvent(pfe-&gt;fd, 0, EPOLLOUT);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else if (read_status == kReadHalf) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          continue;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          log_info(&quot;Get request error %d\n&quot;, read_status);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          should_close = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      if ((pfe-&gt;mask &amp; EPOLLERR) || (pfe-&gt;mask &amp; EPOLLHUP) || should_close) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          log_info(&quot;close connection %d reason %d %d\n&quot;, pfe-&gt;fd, pfe-&gt;mask, should_close);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          pink_epoll_-&gt;PinkDelEvent(pfe-&gt;fd);  // 如果关闭则删除该事件</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          CloseFd(conn);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          fd_conns_.erase(pfe-&gt;fd);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          if (ipport_conns_.count(conn-&gt;ip_port())) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ipport_conns_.erase(conn-&gt;ip_port());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          if (connecting_fds_.count(conn-&gt;fd())) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            connecting_fds_.erase(conn-&gt;fd());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  return nullptr;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>通过client_thread的执行函数可知，这是一个标准的事件驱动模型。如果可写入则调用conn的SendReply函数，如果是接受事情则调用conn的GetRequest函数。此时的conn就是PbConn。</p>
<div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// Msg is [ length(COMMAND_HEADER_LENGTH) | body(length bytes) ]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//   step 1. kHeader, we read COMMAND_HEADER_LENGTH bytes;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//   step 2. kPacket, we read header_len bytes;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ReadStatus PbConn::GetRequest() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  while (true) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    switch (connStatus_) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      case kHeader: {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ssize_t nread = read(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            fd(), rbuf_ + cur_pos_, COMMAND_HEADER_LENGTH - cur_pos_); // 解析头部信息</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (nread == -1) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          if (errno == EAGAIN) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return kReadHalf;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return kReadError;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else if (nread == 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          return kReadClose;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          cur_pos_ += nread;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          if (cur_pos_ == COMMAND_HEADER_LENGTH) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            uint32_t integer = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            memcpy(reinterpret_cast&lt;char*&gt;(&amp;integer),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                   rbuf_, sizeof(uint32_t));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            header_len_ = ntohl(integer);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            remain_packet_len_ = header_len_;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            connStatus_ = kPacket;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            continue;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          return kReadHalf;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      case kPacket: {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (header_len_ &gt; rbuf_len_ - COMMAND_HEADER_LENGTH) {  //解析packet</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          uint32_t new_size = header_len_ + COMMAND_HEADER_LENGTH;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          if (new_size &lt; kProtoMaxMessage) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            rbuf_ = reinterpret_cast&lt;char *&gt;(realloc(rbuf_, sizeof(char) * new_size));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (rbuf_ == NULL) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">              return kFullError;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            rbuf_len_ = new_size;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            log_info(&quot;Thread_id %ld Expand rbuf to %u, cur_pos_ %u\n&quot;, pthread_self(), new_size, cur_pos_);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return kFullError;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // read msg body</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ssize_t nread = read(fd(), rbuf_ + cur_pos_, remain_packet_len_);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (nread == -1) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          if (errno == EAGAIN) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return kReadHalf;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return kReadError;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else if (nread == 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          return kReadClose;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        cur_pos_ += nread;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        remain_packet_len_ -= nread;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (remain_packet_len_ == 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          connStatus_ = kComplete;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          continue;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return kReadHalf;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      case kComplete: {  //解析完成之后调用DealMessage函数来处理</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (DealMessage() != 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          return kDealError;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        connStatus_ = kHeader;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        cur_pos_ = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return kReadAll;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      // Add this switch case just for delete compile warning</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      case kBuildObuf:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      case kWriteObuf:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  return kReadHalf;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">WriteStatus PbConn::SendReply() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ssize_t nwritten = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  size_t item_len;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  slash::MutexLock l(&amp;resp_mu_);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  while (!write_buf_.queue_.empty()) {  //写入的队列是否为空</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    std::string item = write_buf_.queue_.front();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    item_len = item.size();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    while (item_len - write_buf_.item_pos_ &gt; 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      nwritten = write(fd(), item.data() + write_buf_.item_pos_, item_len - write_buf_.item_pos_);   // 将数据写入对应的文件描述符</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      if (nwritten &lt;= 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      write_buf_.item_pos_ += nwritten;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      if (write_buf_.item_pos_ == item_len) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        write_buf_.queue_.pop();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        write_buf_.item_pos_ = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        item_len = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (nwritten == -1) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      if (errno == EAGAIN) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return kWriteHalf;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Here we should close the connection</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return kWriteError;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (item_len - write_buf_.item_pos_ != 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      return kWriteHalf;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  return kWriteAll;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>从client的事件驱动可知，处理的主要的逻辑函数就是自定义的DealMessage()函数。</p>
<p>我们继续分析PikaReplClientConn类。</p>
<p>在pika_repl_client_thread.h的定义中。</p>
<div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class PikaReplClientThread : public pink::ClientThread {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> public:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  PikaReplClientThread(int cron_interval, int keepalive_timeout);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  virtual ~PikaReplClientThread() = default;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  int Start();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> private:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  class ReplClientConnFactory : public pink::ConnFactory {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   public:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    virtual std::shared_ptr&lt;pink::PinkConn&gt; NewPinkConn(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int connfd,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        const std::string &amp;ip_port,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        pink::Thread *thread,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        void* worker_specific_data,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        pink::PinkEpoll* pink_epoll) const override {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      return std::static_pointer_cast&lt;pink::PinkConn&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        (std::make_shared&lt;PikaReplClientConn&gt;(connfd, ip_port, thread, worker_specific_data, pink_epoll));  // 新连接进来的时候通过初始化成PikaReplClientConn</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  class ReplClientHandle : public pink::ClientHandle {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   public:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void CronHandle() const override {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void FdTimeoutHandle(int fd, const std::string&amp; ip_port) const override;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void FdClosedHandle(int fd, const std::string&amp; ip_port) const override;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    bool AccessHandle(std::string&amp; ip) const override {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      // ban 127.0.0.1 if you want to test this routine</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      // if (ip.find(&quot;127.0.0.2&quot;) != std::string::npos) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      //   std::cout &lt;&lt; &quot;AccessHandle &quot; &lt;&lt; ip &lt;&lt; std::endl;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      //   return false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      // }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      return true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int CreateWorkerSpecificData(void** data) const override {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int DeleteWorkerSpecificData(void* data) const override {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void DestConnectFailedHandle(std::string ip_port, std::string reason) const override {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ReplClientConnFactory conn_factory_;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ReplClientHandle handle_;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>由于每次client_thread都会将新连接通过PikaReplClientConn来初始化，故每次有事件驱动的时候就调用该PikaReplClientConn的Dealmessage函数，来处理解析的数据。</p>
<div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int PikaReplClientConn::DealMessage() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  std::shared_ptr&lt;InnerMessage::InnerResponse&gt; response =  std::make_shared&lt;InnerMessage::InnerResponse&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ::google::protobuf::io::ArrayInputStream input(rbuf_ + cur_pos_ - header_len_, header_len_);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ::google::protobuf::io::CodedInputStream decoder(&amp;input);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  decoder.SetTotalBytesLimit(g_pika_conf-&gt;max_conn_rbuf_size(), g_pika_conf-&gt;max_conn_rbuf_size());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  bool success = response-&gt;ParseFromCodedStream(&amp;decoder) &amp;&amp; decoder.ConsumedEntireMessage();  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  if (!success) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    LOG(WARNING) &lt;&lt; &quot;ParseFromArray FAILED! &quot; &lt;&lt; &quot; msg_len: &quot; &lt;&lt; header_len_;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    g_pika_server-&gt;SyncError();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return -1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  switch (response-&gt;type()) {  // 根据协议解析的类型来判断执行什么操作</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    case InnerMessage::kMetaSync:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      ReplClientTaskArg* task_arg = new ReplClientTaskArg(response, std::dynamic_pointer_cast&lt;PikaReplClientConn&gt;(shared_from_this()));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      g_pika_rm-&gt;ScheduleReplClientBGTask(&amp;PikaReplClientConn::HandleMetaSyncResponse, static_cast&lt;void*&gt;(task_arg));  // 如果是元数据同步，将该事件放入到处理线程池中执行</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    case InnerMessage::kDBSync:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      ReplClientTaskArg* task_arg = new ReplClientTaskArg(response, std::dynamic_pointer_cast&lt;PikaReplClientConn&gt;(shared_from_this()));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      g_pika_rm-&gt;ScheduleReplClientBGTask(&amp;PikaReplClientConn::HandleDBSyncResponse, static_cast&lt;void*&gt;(task_arg));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    case InnerMessage::kTrySync:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      ReplClientTaskArg* task_arg = new ReplClientTaskArg(response, std::dynamic_pointer_cast&lt;PikaReplClientConn&gt;(shared_from_this()));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      g_pika_rm-&gt;ScheduleReplClientBGTask(&amp;PikaReplClientConn::HandleTrySyncResponse, static_cast&lt;void*&gt;(task_arg));  // 如果是同步则放入线程池中去执行HandleTrySyncResponse函数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    case InnerMessage::kBinlogSync:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      DispatchBinlogRes(response);  // binlog同步处理</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    case InnerMessage::kRemoveSlaveNode:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      ReplClientTaskArg* task_arg = new ReplClientTaskArg(response, std::dynamic_pointer_cast&lt;PikaReplClientConn&gt;(shared_from_this()));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      g_pika_rm-&gt;ScheduleReplClientBGTask(&amp;PikaReplClientConn::HandleRemoveSlaveNodeResponse, static_cast&lt;void*&gt;(task_arg));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    default:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>至此，一个pika_repl_client的整个的处理流程就清晰，即每次都会根据协议调用PikaReplClientConn的DealMessage函数，将每个执行任务放入线程池中去处理。</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="pika_repl_server线程">pika_repl_server线程<a class="hash-link" aria-label="pika_repl_server线程的直接链接" title="pika_repl_server线程的直接链接" href="/docs/设计与实现/主从同步/#pika_repl_server线程">​</a></h4>
<p>该线程的核心思想与pika_repl_client的处理流程差不多 ，只不过在pink中对应的是HolyThread，处理流程大同小异，最终调用的就是PikaReplServerConn的DealMessage方法。</p>
<div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int PikaReplServerConn::DealMessage() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  std::shared_ptr&lt;InnerMessage::InnerRequest&gt; req = std::make_shared&lt;InnerMessage::InnerRequest&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  bool parse_res = req-&gt;ParseFromArray(rbuf_ + cur_pos_ - header_len_, header_len_);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  if (!parse_res) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    LOG(WARNING) &lt;&lt; &quot;Pika repl server connection pb parse error.&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return -1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  switch (req-&gt;type()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    case InnerMessage::kMetaSync:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      ReplServerTaskArg* task_arg = new ReplServerTaskArg(req, std::dynamic_pointer_cast&lt;PikaReplServerConn&gt;(shared_from_this()));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      g_pika_rm-&gt;ScheduleReplServerBGTask(&amp;PikaReplServerConn::HandleMetaSyncRequest, task_arg);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    case InnerMessage::kTrySync:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      ReplServerTaskArg* task_arg = new ReplServerTaskArg(req, std::dynamic_pointer_cast&lt;PikaReplServerConn&gt;(shared_from_this()));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      g_pika_rm-&gt;ScheduleReplServerBGTask(&amp;PikaReplServerConn::HandleTrySyncRequest, task_arg);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    case InnerMessage::kDBSync:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      ReplServerTaskArg* task_arg = new ReplServerTaskArg(req, std::dynamic_pointer_cast&lt;PikaReplServerConn&gt;(shared_from_this()));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      g_pika_rm-&gt;ScheduleReplServerBGTask(&amp;PikaReplServerConn::HandleDBSyncRequest, task_arg);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    case InnerMessage::kBinlogSync:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      ReplServerTaskArg* task_arg = new ReplServerTaskArg(req, std::dynamic_pointer_cast&lt;PikaReplServerConn&gt;(shared_from_this()));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      g_pika_rm-&gt;ScheduleReplServerBGTask(&amp;PikaReplServerConn::HandleBinlogSyncRequest, task_arg);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    case InnerMessage::kRemoveSlaveNode:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      ReplServerTaskArg* task_arg = new ReplServerTaskArg(req, std::dynamic_pointer_cast&lt;PikaReplServerConn&gt;(shared_from_this()));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      g_pika_rm-&gt;ScheduleReplServerBGTask(&amp;PikaReplServerConn::HandleRemoveSlaveNodeRequest, task_arg);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    default:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="主从同步的流程">主从同步的流程<a class="hash-link" aria-label="主从同步的流程的直接链接" title="主从同步的流程的直接链接" href="/docs/设计与实现/主从同步/#主从同步的流程">​</a></h3>
<p>pika_repl_server的流程可用如图描述。</p>
<p><img decoding="async" loading="lazy" src="https://img-blog.csdnimg.cn/f5f65e0cb6e74b45a9afbc45933ab12f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP5bGL5a2Q5aSn5L6g,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述" class="img_ev3q"></p>
<p>pika_repl_client的流程可用如图描述。</p>
<p><img decoding="async" loading="lazy" src="https://img-blog.csdnimg.cn/8cd2006d23814034b0b6372412506363.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP5bGL5a2Q5aSn5L6g,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述" class="img_ev3q"></p>
<p>主从的状态机流程如下。</p>
<p><img decoding="async" loading="lazy" src="https://img-blog.csdnimg.cn/9fbd751015384d198c2ea514e4ca84b6.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP5bGL5a2Q5aSn5L6g,size_12,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述" class="img_ev3q"></p>
<p>通过如上三个图就可以能够明白pika官网描述的主从同步的流程图。</p>
<p><a href="https://github.com/OpenAtomFoundation/pika/wiki/pika-%E5%A2%9E%E9%87%8F%E5%90%8C%E6%AD%A5" target="_blank" rel="noopener noreferrer">pika-增量同步</a></p>
<p><a href="https://github.com/OpenAtomFoundation/pika/wiki/pika-%E5%85%A8%E5%90%8C%E6%AD%A5" target="_blank" rel="noopener noreferrer">pika-全同步</a></p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="总结">总结<a class="hash-link" aria-label="总结的直接链接" title="总结的直接链接" href="/docs/设计与实现/主从同步/#总结">​</a></h2>
<p>本文根据pika官网的流程，分析了一下pika主从的一个大致流程，其中还包含了很多的技术细节限于本文篇幅并没有详尽分析，主要通过原理流程的一个分析来查看了主从同步的状态机线程，和主从同步的线程模型的基本原理。由于本人才疏学浅，如有错误请批评指正。</p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="row margin-top--sm theme-doc-footer-edit-meta-row"><div class="col"><a href="https://github.com/OpenAtomFoundation/PikiwiDB-Pika--Website/tree/main/docs/设计与实现/主从同步/index.md" target="_blank" rel="noopener noreferrer" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>编辑此页</a></div><div class="col lastUpdated_JAkA"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="文件选项卡"><a class="pagination-nav__link pagination-nav__link--prev" href="/docs/设计与实现/增量同步/"><div class="pagination-nav__sublabel">上一页</div><div class="pagination-nav__label">增量同步</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/docs/设计与实现/副本一致性/"><div class="pagination-nav__sublabel">下一页</div><div class="pagination-nav__label">副本一致性</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a class="table-of-contents__link toc-highlight" href="/docs/设计与实现/主从同步/#pika主从同步">pika主从同步</a></li><li><a class="table-of-contents__link toc-highlight" href="/docs/设计与实现/主从同步/#pika主从同步原理">pika主从同步原理</a><ul><li><a class="table-of-contents__link toc-highlight" href="/docs/设计与实现/主从同步/#auxiliary_thread线程">auxiliary_thread线程</a></li><li><a class="table-of-contents__link toc-highlight" href="/docs/设计与实现/主从同步/#pika_repl_client和pika_repl_server_线程">pika_repl_client和pika_repl_server_线程</a></li><li><a class="table-of-contents__link toc-highlight" href="/docs/设计与实现/主从同步/#主从同步的流程">主从同步的流程</a></li></ul></li><li><a class="table-of-contents__link toc-highlight" href="/docs/设计与实现/主从同步/#总结">总结</a></li></ul></div></div></div></div></main></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">微信公众号</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://mp.weixin.qq.com/s/CvIdQs3g31DC8JztyymuqQ" target="_blank" rel="noopener noreferrer" class="footer__link-item">PikiwiDB 公众号<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">Github 仓库</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://github.com/OpenAtomFoundation/pika" target="_blank" rel="noopener noreferrer" class="footer__link-item">PikiwiDB 仓库<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">文档仓库</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://github.com/OpenAtomFoundation/PikiwiDB-Pika--Website" target="_blank" rel="noopener noreferrer" class="footer__link-item">PikiwiDB 文档仓库<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2025 PikiwiDB 开源数据库社区</div></div></div></footer></div>
</body>
</html>